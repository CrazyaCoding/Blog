---
layout: post
title: 冒泡排序
tags:
- 算法
- 排序
- js
categories: js
---
## 概念
冒泡排序(Bubble Sort)是排序算法里面比较简单的一个排序。它重复地走访要排序的数列，一次比较两个数据元素，如果顺序不对则进行交换，并一直重复这样的走访操作，直到没有交换的数据元素为止。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

## 算法步骤
1. 比较**相邻**的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一堆数字需要比较。
![冒泡排序](https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-Lm9JtwbhXVOfXyecToy%2F-Lm9KQIJAMvCgJQzErQS%2F-Lm9KRSInFt3BHoLgdXb%2FbubbleSort.gif?generation=1565688974562234&alt=media)


## 代码
```
function bubbleSort(arr = {}) {
    let len = arr.length;
    if (len <= 0) {
        return [];
    }
    for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

## 冒泡排序的特点及性能
**时间复杂度O(n^2)**
通过冒泡排序的算法思想，我们发现冒泡排序算法在每轮排序中会使一个元素排到一端，也就是最终需要n-1轮这样的排序（n为待排序的数列的长度），而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，所以这里的时间复杂度的O(n^2)。在待排序的数列本身就是我们想要的排序结果时，时间复杂度的确是O(n)，因为只需要一轮排序并且不用交换。但是实际上这种情况很少，所以冒泡排序的平均时间复杂度是O(n^2)。

**空间复杂度O(1)**
对于空间复杂度来说，冒泡排序用到的额外的存储空间只有一个，那就是用于交换位置的临时变量，其他所有操作都是在原油待排序列上处理的，所以空间复杂度为O(1)。

**稳定性**
冒泡排序是**稳定**的，因为在比较的过程中，只有后一个元素比前面的元素大时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的。

## 冒泡排序的适用场景
对于冒泡排序，我们应该对它的思想进行理解，作为排序算法学习的引导，让我们的思维更加开阔。

虽然冒泡排序在我们的实际工作中并不会用到，其他排序算法多多少少比冒泡排序算法的性能更高，但是我们还是要掌握冒泡排序的思想及实现，并且在面试时还有可能会用到。





## 参考
[冒泡排序算法原理及实现（超详细）](http://data.biancheng.net/view/116.html)

[冒泡排序](https://sort.hust.cc/1.bubblesort)