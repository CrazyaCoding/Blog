## 问题
查找单链表中的倒数第K个结点（k > 0），例如 1->2->3->4->6->7->9->10 链表倒数第3个节点是7，输入值为链表和k
## 思路
1、为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍链表，求出整个链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来再遍历一次就可以得到结果。但是该方法存在一个问题，即需要对链表进行两次遍历，第一次遍历用于求解链表的长度，第二次遍历用于查找正数第n-k个节点。

2、显然，这种方法还可以优化。如果从头至尾从链表中的某个元素开始，遍历k个元素后刚好达到链表尾，那么该元素就是要找到的倒数第k个元素。根据这一性质，设计如下研发：从头节点开始，依次对链表的每一个节点元素进行这一的测试，遍历k个元素，查看是否到达链表尾，直到找到那个倒数第k个元素。此种方法将对同一批元素进行反复多次的遍历，对于链表中的大部分元素而言，都要遍历k个元素，如果链表长度为n个的话，该算法的时间复杂度为O(kn)级，效率太低。

3、**存在另外一种更高效的方式，只需要一次遍历即可查找到倒数第k个元素，由于链表只能从头到尾依次访问链表的各个节点。因此，如果要找到链表的倒数第k个元素的话，也只能从头到为进行遍历查找，在查找的过程中，设置两个指针，让其中一个指针比另一个指针先前移动k-1步，然后两个指针同时往前移动。循环直到线性的指针值为null时，另一个指针位置就是要找到的位置。**

下面以上述第3种方式来看代码实现
## 代码
假设有甲、乙两个同学走路，两人迈步一样大，都在起跑线上，前面是墙(俩人位置距离墙就是链表长度)，求距离墙30步的位置。那么先让乙走30-1步，甲原地不动。接下来甲一步，乙一步往前溜达。当乙到墙的时候，停止行走，此时甲的位置就是距离墙30步的位置。
```javascript
/**
 * 
 * @param {*} head 链表头节点
 * @param {*} k 倒数第k个
 */
function findNode(head, k) {
    if (!k || k < 1) {
        throw new Error('k参数不合法');
    }
    let p1 = head, // 一个指针
        p2 = head; // 要寻找的节点
    // p2先移动k步 或者先移动到末尾
    // 这里从0开始算 所以是到k-1结束 为最后一个
    // 肯定默认k<=节点长度
    for (let i = 0; i < k - 1; i++) {
        if (p1.next === null) {
            break;
        }
        p1 = p1.next;
    }
    // 现在p1与p2 中间相隔k-1-1个节点(-1-1相当于减去p1 p2本身) 所以当p1是最后一个的时候 p2正好是倒数第k个
    // null不算一个节点 所以p1.next是最后一个节点 到此循环截止
    while (p1.next !== null) {
        p1 = p1.next;
        p2 = p2.next;
    }
    return p2;
}
```
## 性能
**时间复杂度O(n)**
有两次循环，取最大那个，循环n = k-1次，so时间复杂度O(n)

**空间复杂度为O(1)**
占用两个空间，当为常数的时候，我们说空间复杂度为O(1)


## 参考
[［算法］找出单链表中的倒数第k个元素](https://blog.csdn.net/codeemperor/article/details/51332514)

[如何找出单链表中的倒数第k个元素](https://www.cnblogs.com/xiohao/p/9143130.html)

[链表--如何查找单链表中倒数第k个元素](https://blog.csdn.net/yangruxi/article/details/80329772)